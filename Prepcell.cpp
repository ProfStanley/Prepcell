#include <iostream>
#include <string.h>
#include <sstream>
#include <fstream>
#include <cstdlib>
#include <iomanip>
//#include <math.h> note that cmath is needed since cstdlib has conflicting definitions for abs(); (I think) CMS 02/23/2016
#include <cmath>
#include <vector>
#include <sys/stat.h>
#include <ctime>

#define PI 3.14159265
int seed = time(0); //time(0);
double time_step = 1.0;//see writeXV function
//  This program prepares the supercell slightly out of equilibrium with
//  most of the cell at temperature Tc and slice 1 at Temperature Th
//  The program should be ran in the same directory as the neccessary input files

//  Input: <systemfile>.fdf (For initial positions, creating the slices, lattic constant, etc)
//         <systemfile>.xyz (This is the same xyz + masses used by the VIBRA package
//         <systemfile>.vectors (Evectors and Evalues, output generated by VIBRA
//  Usage: prepcell <systemfile> TCold THot
//  Output: $systemname.XV

using namespace std;


//**********************************data structures *********************************

struct vec3D {
        double coor[3];
};

struct evector {
        vector<vec3D> atom;
};

struct dynamicalmatrix {
        int numAtoms;
        int numModes;
        vector<double> frequency;
        vector<evector> evec;
};

struct supercell {
        int numAtoms;
        vector<vec3D> atom;
};

struct XV {
        vector<vec3D> pos;
        vector<vec3D> vel;
};

struct temperature {
        vector<double> slice;
};

struct tempsTime {
        double szTime;
        vector<temperature> T;
};

struct slice {
        vector<int> atoms;
};

struct all_slices {
        vector<slice> sl;
};

struct fdfInfo {
        string syslabel;
        int numAtoms;
        int numSpecies;
        int numTimeSteps;
        double szTimeStep;
        double latConst;
        double latVec1[3];
        double latVec2[3];
        double latVec3[3];
        vector<int> atomType;
        vector<int> atomNum;
};

//*******************************function declarations***********************************************
bool fileExists(string);

void readFDF(string, fdfInfo&);
void readEquilibriumPosition (string, int, supercell&, vector<double>&);
void readDynamicalMatrix (string, int, dynamicalmatrix&);

void prepcell(supercell&, fdfInfo&, dynamicalmatrix&, double, XV&, vector<double>&, vector<double>&);
void defineSlices(all_slices&, fdfInfo&, int);

double calcTempSlice(XV&, all_slices&, int, vector<double>&, int);
double calcColdPart(XV&, all_slices&, int, vector<double>&);
void rescaleSliceOne(XV&, double, slice&, supercell&);

void writeXV(string, XV&, fdfInfo&, double, double, FILE*);
void writebinXV(string, XV&, fdfInfo&, double, double);
void WriteRandNums(fdfInfo& info, vector<double> randnums,vector<double> randnums2);
void ReadRandNums(fdfInfo& info,vector<double>& randnums,vector<double>& randnums2);
void WriteRandNums(fdfInfo& info,vector<double> randnums,vector<double> randnums2)
{

       int i;
       ofstream output("randnums.txt", ios::out);
       output<<setprecision(100);
       output<<seed<<endl;
       for(i=0; i<3*info.numAtoms; i++) {
         output<<randnums[i]<<endl;
       }

       for(i=0; i<3*info.numAtoms; i++) {
         output<<randnums2[i]<<endl;
       }
       output.close();
}
void ReadRandNums(fdfInfo& info,vector<double>& randnums,vector<double>& randnums2){
       int i;
       ifstream input("randnums.txt", ios::in);

       for(i=0; i<3*info.numAtoms; i++) {
          input>>randnums[i];
//cout << randnums[i]<< endl;
       }
//cout<< randnums2[100]<< endl;
       for(i=0; i<3*info.numAtoms; i++) {
          input>>randnums2[i];
       }
//cout<< randnums2[100]<< endl;
       input.close();


}

//*************************************** main ********************************************************

int main(int argc, char *argv[]) {
  int i,n, t;
  double TempHS = 0.0, Temp1 = 0.0, TCold = 0.0, THot = 0.0, Temp2 = 0.0, Temp3 = 0.0, Temp4 = 0.0;

  double Scale = -1.0;
  vector<double> masses;
  string fdfname, mdxname, xyzname, vectorname, xvname;
  size_t found;
  fdfInfo info;
  all_slices cellDef;
  supercell equPos;
  temperature curTemp;
  tempsTime allTemps;
  dynamicalmatrix dm;
  XV initXV;
  vector<double> coldAmps;
  FILE *fp;

  //check user input
  if(argc>3) {
    //  Check if the filename provided includes the extension fdf
    fdfname=argv[1];
    found=fdfname.find(".fdf");
    if(found==string::npos) fdfname+=".fdf";
    //  Check if the fdf file exists
    if(!fileExists(fdfname)) {
      cout<<"The fdf file doesn't exist."<<endl;
      exit(1);
    }
    //  Second Argument is TCold Third is THot
    TCold=atoi(argv[2]);
    THot=atoi(argv[3]);
  }
  else {
    cout<<"Too few arguments."<<endl;
    cout<<"The correct usage is: "<<argv[0]<<" filename Tcold Thot"<<endl;
    exit(1);
  }

  //get data from various files
  readFDF(fdfname, info);
  vectorname=info.syslabel;
  vectorname+=".vectors";
  readDynamicalMatrix(vectorname, info.numAtoms, dm);
  xyzname=info.syslabel;
  xyzname+=".xyz";
  readEquilibriumPosition(xyzname, info.numAtoms, equPos, masses);

  //define the slices (hard coded in the function below)
  defineSlices(cellDef, info, 6);

  srand(seed);
  printf("seed = %i\n",seed);
  //prep the entire cell at the temperature TCold given by the user
  prepcell(equPos, info, dm, TCold, initXV, coldAmps, masses);

  //calc temps once the entire supercell is prepared
  TempHS = calcTempSlice(initXV, cellDef, info.numAtoms, masses, 0);
  Temp1  = calcTempSlice(initXV, cellDef, info.numAtoms, masses, 1);
  Temp2  = calcTempSlice(initXV, cellDef, info.numAtoms, masses, 2);
  Temp3  = calcTempSlice(initXV, cellDef, info.numAtoms, masses, 3);
  Temp4  = calcTempSlice(initXV, cellDef, info.numAtoms, masses, 4);


  //rescale each of the slices to be the correct temperature, this minimizes noise
  Scale=sqrt(THot/TempHS);
  rescaleSliceOne(initXV, Scale, cellDef.sl[0], equPos);
  TempHS = calcTempSlice(initXV, cellDef, info.numAtoms, masses, 0);

  Scale = sqrt(TCold/Temp1);
  rescaleSliceOne(initXV, Scale, cellDef.sl[1], equPos);
  Temp1 = calcTempSlice(initXV, cellDef, info.numAtoms, masses, 1);

  Scale = sqrt(TCold/Temp2);
  rescaleSliceOne(initXV, Scale, cellDef.sl[2], equPos);
  Temp2 = calcTempSlice(initXV, cellDef, info.numAtoms, masses, 2);

  Scale = sqrt(TCold/Temp3);
  rescaleSliceOne(initXV, Scale, cellDef.sl[3], equPos);
  Temp3 = calcTempSlice(initXV, cellDef, info.numAtoms, masses, 3);

  //slice 4 should be re-scaled at this point, since it consists of slices 1,2,and3
  Temp4  = calcTempSlice(initXV, cellDef, info.numAtoms, masses, 4);

  xvname=info.syslabel;                         // Output final results
  xvname+=".XV";
  fp = fopen(xvname.c_str(), "w");
  writeXV(xvname, initXV, info, TCold, THot, fp);       // Temps and seed hardcoded for now
  fclose(fp);

  cout<<"slice temperatures are"<<endl;
  printf("abs(1-TempHS/THot)===== %lf   TempHS===== %lf\n",  abs(1-TempHS/THot),TempHS); //aka "slice0"
  printf("abs(1-Temp1/TCold) ===== %lf   Temp1 ===== %lf\n",  abs(1-Temp1/TCold), Temp1);
  printf("abs(1-Temp2/TCold) ===== %lf   Temp2 ===== %lf\n",  abs(1-Temp2/TCold), Temp2);
  printf("abs(1-Temp3/TCold) ===== %lf   Temp3 ===== %lf\n",  abs(1-Temp3/TCold), Temp3);
  printf("abs(1-Temp4/TCold) ===== %lf   Temp4 ===== %lf\n",  abs(1-Temp4/TCold), Temp4);

  return 0;
}


//******************************************** subroutines ****************************************************************

bool fileExists(string filename) {
  struct stat stFileInfo;
  bool blnReturn;
  int intStat;

  intStat = stat(filename.c_str(),&stFileInfo);
  if(intStat == 0) {
    blnReturn = true;
  } else {
    blnReturn = false;
  }

  return(blnReturn);
}

void readFDF(string filename, fdfInfo& info) {
   int i, j, firstStep, finalStep, curANum, curAType;
   double x, y, z;
   string buff2;
   string buff, testfield;

   ifstream input(filename.c_str(), ios::in);
   if(!input) {
        cout<<"Could not find the file "<<filename<<".  This should be the fdf input file for SIESTA."<<endl;
        exit(1);
   }
   while(input>>buff) {
      i=0;
      while(buff[i]) {buff[i]=tolower(buff[i]); i++;}
      if(buff.compare("systemlabel")==0) input>>info.syslabel;
      if(buff.compare("numberofatoms")==0) input>>info.numAtoms;
      if(buff.compare("numberofspecies")==0) input>>info.numSpecies;
      if(buff.compare("md.initialtimestep")==0) input>>firstStep;
      if(buff.compare("md.finaltimestep")==0) input>>finalStep;
      if(buff.compare("md.lengthtimestep")==0) input>>info.szTimeStep;
      if(buff.compare("latticeconstant")==0) input>>info.latConst;
      if(buff.compare("%block")==0) {
         input>>testfield;
         j=0;
         while(testfield[j]) {testfield[j]=tolower(testfield[j]); j++;}
         if(testfield.compare("latticevectors")==0) {
            for(j=0;j<3;j++) {
               input>>info.latVec1[j];
            }
            for(j=0;j<3;j++) {
               input>>info.latVec2[j];
            }
            for(j=0;j<3;j++) {
               input>>info.latVec3[j];
            }
         }
         if(testfield.compare("chemicalspecieslabel")==0) {
            info.atomNum.clear();                               // initialize atomic number array
            for(j=0; j<info.numSpecies; j++) {          // Currently requires labels to be sequentially ordered in the fdf
               input>>x;                                // It also does not treat comments correctly
               input>>curANum;
               input>>buff2;
               info.atomNum.push_back(curANum);
            }
         }
         if(testfield.compare("atomiccoordinatesandatomicspecies")==0) {
            info.atomType.clear();              // initialize atomic type array
            for(j=0; j<info.numAtoms; j++) {
               input>>x>>y>>z>>curAType>>buff2>>buff2;
               info.atomType.push_back(curAType);
            }
         }
      }
   }
   info.numTimeSteps=finalStep-firstStep+1;
   input.close();
}

void readEquilibriumPosition(string filename, int numAtoms, supercell& equPos, vector<double>& masses) {
        char buff[200];
        int i;
        double curMass;
        vec3D curCoor;

        ifstream input(filename.c_str(), ios::in);
        if(!input) {
                cout<<"Could not find the file "<<filename<<".  This is list of coordinates in the xyz format (x y z species(#) mass) the default name is rcoord."<<endl;
                exit(0);
        }

        equPos.atom.clear();
        equPos.numAtoms=numAtoms;
        masses.clear();
        for(i=0; i<3; i++) {                    //  Intialize the temporary vector
                curCoor.coor[i]=0;
        }

        i=0;
        while(input >> curCoor.coor[0] >> curCoor.coor[1] >> curCoor.coor[2] >> buff >> curMass) {
                equPos.atom.push_back(curCoor);
                masses.push_back(curMass);
                i++;
        }

        input.close();
}

void readDynamicalMatrix (string filename, int numAtoms, dynamicalmatrix& dm) {
        //      filename is the name of the .vectors file produced by vibrator
        //      numAtoms the number of atoms in the supercell
        //      dm the structure containing all eigenvectors and eigenmodes of the supercell

        char buff[200];                         //  dummy variable used for parsing the .vectors file
        int i, j, k, numModes, curInd, curMode;
        double curEval, curEvectCoor[3];
        vec3D empty_vec3D;
        evector empty_evec;
        vector<double> curVec;                  //  A temporary vector

        // Initialization
        curMode = 0;
        dm.numAtoms = 0;
        dm.numModes = 0;
        dm.frequency.clear();
        dm.evec.clear();                                        //  Erase everything in dm (if it exists);

        numModes = numAtoms * 3;

        for(i=0; i<3; i++) { empty_vec3D.coor[i]=0.0; }

        for(i=0; i<numAtoms; i++) { empty_evec.atom.push_back(empty_vec3D); }

        for(i=0; i<numModes; i++) {                     // Create and empty data structure of the correct size
                dm.frequency.push_back(0.0);
                dm.evec.push_back(empty_evec);
        }

        ifstream input(filename.c_str(), ios::in);
        if(!input) {
                cout<<"Could not find the file "<<filename<<endl<<"This is output from vibrator(or the fc_cb script) and contains the eigenvectors and the normal modes of the system."<<endl;
                exit(0);
        }

        dm.numAtoms = numAtoms;
        dm.numModes = numModes;
        while(input>>buff) {
                if(strcmp(buff,"Eigenvector") == 0) {           // Find the start of an Eigenvector
                        input>>buff;                            // ignore =
                        input>>curMode;                         // Store Current mode number
                        input>>buff>>buff;                      // ignore "Frequency = " string
                        input>>curEval;                         // store frequency value
                        dm.frequency[curMode-1]=curEval;
                        input>>buff>>buff>>buff;                // ignore "Eigenmode (real part)" string
                        for(j=0;j<numAtoms;j++) {
                                input>>curEvectCoor[0]>>curEvectCoor[1]>>curEvectCoor[2];       // store x, y, z
                                for(k=0; k<3; k++) { dm.evec[curMode-1].atom[j].coor[k] = curEvectCoor[k]; }
                        }
                }
        }
        input.close();
}

void prepcell(supercell& equPos, fdfInfo& info, dynamicalmatrix& dm, double T, XV& initXV, vector<double>& amps, vector<double>& masses){
  double kbolz, hbar, evConvert;
  vector<double> randnums;      // random phases phi_s
  vector<double> randnums2;     // random energies (boltzmann distribution)
  double samp, temp;
  double Erand, Et, ratio;
  int i, j, k, s, alpha, seed, curInd;
  vec3D emptyVec;
  // constants
  evConvert = 103.6426;
  hbar = 0.0063508935;                  // Ang^2*amu/fs
  kbolz = 1.38065030/(1.660538*pow(10.0,6));  //Ang^2*amu/fs^2*K
  // select random numbers
  //seed=2003470294;

  for(i=0; i<3*info.numAtoms; i++) {
    randnums.push_back(2*PI*double(rand())/double(RAND_MAX)); // range from 0 to 2Pi
    randnums2.push_back(double(rand())/double(RAND_MAX));         // range 0 to 1 (normalized)
    amps.push_back(0.0);                                          // initialize amplitudes
  }

  //////////        ReadRandNums(info,randnums,randnums2);

  // Initialize output initXV
  for(i=0; i<3; i++) emptyVec.coor[i]=0.0;

  initXV.pos.clear();
  initXV.vel.clear();
  for(alpha=0; alpha<info.numAtoms; alpha++) {
    initXV.pos.push_back(emptyVec);
    initXV.vel.push_back(emptyVec);
  }

  //  Determine initial coordinates and velocities
  Erand = 0.0;
  for(s=6; s<3*info.numAtoms; s++) {//s=3--> s=15
    Erand+=-kbolz*T*log(1-randnums2[s]);
  }
  Et=(3*info.numAtoms-6)*kbolz*T;
  ratio=Et/Erand;

  for(s=6;s<3*info.numAtoms; s++) {//s=3--> s=15
    // the energies of the amplitudes a randomly distributed over a boltzman distribution
    //  with the sum of energies equal to (3N-3)kT
    amps[s]=sqrt(-2.0*ratio*kbolz*T*log(1-randnums2[s]))/(dm.frequency[s]*0.00002998*2.0*PI);   //  Frequency in inverse fm
    //  printf("ratio=%lf\n",ratio);
    //          printf("kbolz=%lf   T = %lf  \n",kbolz, T);
    //          printf("randnums2[%i] = %lf\n",s,randnums2[s]);
    //          printf("dm.frequency[%i] = %lf\n",s, dm.frequency[s]);
  }
  amps[0]=0.0;
  amps[1]=0.0;
  amps[2]=0.0;
  amps[3]=0.0;
  amps[4]=0.0;
  amps[5]=0.0;
  amps[6]=0.0;
  amps[7]=0.0;
  amps[8]=0.0;

  WriteRandNums(info,randnums,randnums2);


  // Convert to Bohr and initialize the initial XV with the equilibrium positions
  for(alpha=0; alpha<info.numAtoms; alpha++) {
    for(i=0; i<3; i++) {
      initXV.pos[alpha].coor[i]=equPos.atom[alpha].coor[i]/.529177249;
      initXV.vel[alpha].coor[i]=0.0;
    }
  }
  //  Convert from evectors to Cartesian
  for(s=0; s<3*info.numAtoms; s++) {
    for(alpha=0; alpha<info.numAtoms; alpha++) {
      for(i=0; i<3; i++) {
        initXV.pos[alpha].coor[i]+=(1.0/sqrt(masses[alpha]))*amps[s]*dm.evec[s].atom[alpha].coor[i]*cos(randnums[s])/.529177249;
        initXV.vel[alpha].coor[i]-=(1.0/sqrt(masses[alpha]))*amps[s]*(dm.frequency[s]*0.00002998*2.0*PI)*dm.evec[s].atom[alpha].coor[i]*sin(randnums[s])/.529177249;
        //cout<<"velocities="<<initXV.vel[alpha].coor[i]<<endl;
        //cout<<amps[s]<<endl;
      }
    }
  }
}



void defineSlices(all_slices& cell, fdfInfo& info, int numSlices) {
  int i;
  double lengthCell, lengthSlice;
  slice emptySlice;

  //  Initialize space for the slices in the cell
  for(i=0; i<numSlices; i++) cell.sl.push_back(emptySlice);

  //define hot slice(0)

  //get the bulk of the atoms in slice (0)
  for(i=1;i<=120;i++){
    cell.sl[0].atoms.push_back(i);
  }

  cell.sl[0].atoms.push_back(122);
  cell.sl[0].atoms.push_back(124);
  cell.sl[0].atoms.push_back(126);
  cell.sl[0].atoms.push_back(127);
  cell.sl[0].atoms.push_back(129);
  cell.sl[0].atoms.push_back(131);
  cell.sl[0].atoms.push_back(132);
  cell.sl[0].atoms.push_back(133);


  //define "defect" slice (where defects are, if any) (1)
  cell.sl[1].atoms.push_back(121);
  cell.sl[1].atoms.push_back(123);
  cell.sl[1].atoms.push_back(125);
  cell.sl[1].atoms.push_back(128);
  cell.sl[1].atoms.push_back(130);
  cell.sl[1].atoms.push_back(134);
  cell.sl[1].atoms.push_back(135);
  cell.sl[1].atoms.push_back(136);
  cell.sl[1].atoms.push_back(138);
  cell.sl[1].atoms.push_back(139);
  cell.sl[1].atoms.push_back(140);
  cell.sl[1].atoms.push_back(141);
  cell.sl[1].atoms.push_back(142);
  cell.sl[1].atoms.push_back(143);
  cell.sl[1].atoms.push_back(144);
  cell.sl[1].atoms.push_back(145);
  cell.sl[1].atoms.push_back(147);
  cell.sl[1].atoms.push_back(148);
  cell.sl[1].atoms.push_back(150);
  cell.sl[1].atoms.push_back(151);
  cell.sl[1].atoms.push_back(152);
  cell.sl[1].atoms.push_back(153);
  cell.sl[1].atoms.push_back(154);
  cell.sl[1].atoms.push_back(155);
  cell.sl[1].atoms.push_back(156);
  cell.sl[1].atoms.push_back(157);
  cell.sl[1].atoms.push_back(158);
  cell.sl[1].atoms.push_back(159);
  cell.sl[1].atoms.push_back(160);
  cell.sl[1].atoms.push_back(161);
  cell.sl[1].atoms.push_back(162);//H
  cell.sl[1].atoms.push_back(137);//H
  cell.sl[1].atoms.push_back(146);//H
  cell.sl[1].atoms.push_back(149);//H


  //Define the C diamond slice (2)
  for(i=163;i<=220;i++){
    cell.sl[2].atoms.push_back(i);
  }

  //Define the final Si slice (3)
  for(i=221;i<=info.numAtoms;i++){
    cell.sl[3].atoms.push_back(i);
  }

  //Define a slice for the cold part (4)
  //Slice4 = Slice1+Slice2+Slice3
  cell.sl[4].atoms.push_back(121);
  cell.sl[4].atoms.push_back(123);
  cell.sl[4].atoms.push_back(125);
  cell.sl[4].atoms.push_back(128);
  cell.sl[4].atoms.push_back(130);
  cell.sl[4].atoms.push_back(134);
  cell.sl[4].atoms.push_back(135);
  cell.sl[4].atoms.push_back(136);
  cell.sl[4].atoms.push_back(138);
  cell.sl[4].atoms.push_back(139);
  cell.sl[4].atoms.push_back(140);
  cell.sl[4].atoms.push_back(141);
  cell.sl[4].atoms.push_back(142);
  cell.sl[4].atoms.push_back(143);
  cell.sl[4].atoms.push_back(144);
  cell.sl[4].atoms.push_back(145);
  cell.sl[4].atoms.push_back(147);
  cell.sl[4].atoms.push_back(148);
  cell.sl[4].atoms.push_back(150);
  cell.sl[4].atoms.push_back(151);
  cell.sl[4].atoms.push_back(152);
  cell.sl[4].atoms.push_back(153);
  cell.sl[4].atoms.push_back(154);
  cell.sl[4].atoms.push_back(155);
  cell.sl[4].atoms.push_back(156);
  cell.sl[4].atoms.push_back(157);
  cell.sl[4].atoms.push_back(158);
  cell.sl[4].atoms.push_back(159);
  cell.sl[4].atoms.push_back(160);
  cell.sl[4].atoms.push_back(161);
  cell.sl[4].atoms.push_back(162);//H
  cell.sl[4].atoms.push_back(137);//H
  cell.sl[4].atoms.push_back(146);//H
  cell.sl[4].atoms.push_back(149);//H

  for(i=163;i<=info.numAtoms;i++){
    cell.sl[4].atoms.push_back(i);
  }

  //Define one slice as Entire Cell(5)
  for(i=1;i<=info.numAtoms;i++){
    cell.sl[5].atoms.push_back(i);
  }

};






double calcTempSlice(XV& velocities, all_slices& cellDefinition, int numAtoms, vector<double>& masses, int slice) {
  int i, alpha, n, curAtom;
  double kineticEnergy, Temp, convVel, v;
  //  double KE, T; //test variables

  convVel=0.009579038; //  Converts (eV/Ang)/amu to Ang/fs^2

  //KE = 0.0;
  kineticEnergy = 0.0;
  for(alpha=0; alpha<cellDefinition.sl[slice].atoms.size(); alpha++){
    curAtom=cellDefinition.sl[slice].atoms[alpha];
    //KE = 0.0;
    for(i=0; i<3; i++) {
      v = velocities.vel[curAtom].coor[i]*.529177249;
      kineticEnergy+=0.5*masses[curAtom]*v*v/convVel;
      //KE+=0.5*masses[curAtom]*v*v/convVel;
    }
    //T = 2*KE/(3*0.00008617); //Temperature of one atom
    //printf("Atom = %i  Slice = %i  Temp = %lf\n", curAtom, slice, T);
  }
  Temp=2*kineticEnergy/(3*cellDefinition.sl[slice].atoms.size()*0.00008617);
  //printf("slicesize = %i     kineticEnergy = %lf  slice = %i\n", cellDefinition.sl[slice].atoms.size(), kineticEnergy, slice);
  //getchar();
  return(Temp);
}

void rescaleSliceOne(XV& xv, double scale, slice& slOne, supercell& equPos) {
// This rescales the Cartesian positions and velocities
        int i, j;
        double deltaR;
        for(j=0; j<slOne.atoms.size(); j++) {
                for(i=0; i<3; i++) {
                        // Scale the displacements relative to the equilibrium positions
                        // Convert equPos to Bohr radii
                        deltaR=xv.pos[slOne.atoms[j]].coor[i]-equPos.atom[slOne.atoms[j]].coor[i]/.52917725;
                        xv.pos[slOne.atoms[j]].coor[i]=equPos.atom[slOne.atoms[j]].coor[i]/.52917725+deltaR*scale*0.95;
                        xv.vel[slOne.atoms[j]].coor[i]*=scale;
                }
        }
}

//Writes Calculated positions and velocities to XV file for SIESTA as Text file
void writeXV(string xvname, XV& initXV, fdfInfo& info, double Tcold, double Thot, FILE *fp) {

  //Declare
  int i, j;
  double latVec[3][3], convert;

  convert = 0.5291772108;

  //Lattice Vector matrix block at top of XV file
  for(i=0; i<3; i++) {
    latVec[i][0]=info.latConst*info.latVec1[i]*1.8897261249936;
    latVec[i][1]=info.latConst*info.latVec2[i]*1.8897261249936;
    latVec[i][2]=info.latConst*info.latVec3[i]*1.8897261249936;
    fprintf(fp,"\t%lf  ", latVec[i][0]);
    fprintf(fp,"%lf  ",   latVec[i][1]);
    fprintf(fp,"%lf        0.00000000        0.00000000        0.00000000\n", latVec[i][2]);
  }

  //Single line with only number of atoms
  fprintf(fp,"        %i\n", info.numAtoms);

  //Meat of XV file. Format from this point on: ChemSpeciesLabel#|Atomic#|x|y|z|Vx|Vy|Vz  (SIESTA needs positions in Bohr
  for(i=0;i<info.numAtoms;i++){
    printf("species Label = %i \t Atomic number = %i   \n",info.atomType[i], info.atomNum[info.atomType[i]-1]);
    fprintf(fp, "   %i \t %i \t %lf \t %lf \t %lf \t %lf \t %lf \t %lf\n",info.atomType[i], info.atomNum[info.atomType[i]-1],
            initXV.pos[i].coor[0]+initXV.vel[i].coor[0]*time_step, initXV.pos[i].coor[1]+initXV.vel[i].coor[1]*time_step, initXV.pos[i].coor[2]+initXV.vel[i].coor[2]*time_step,
            initXV.vel[i].coor[0],                                 initXV.vel[i].coor[1],                                 initXV.vel[i].coor[2]);
    //info.atomNum[info.atomType[i]-1], -1 for correct index to give correct atomic number (# protons)
  }
}



void writebinXV(string xvname, XV& initXV, fdfInfo& info, double Tcold, double Thot) {
        int i, j;
        double latVec[3][3];
        int icount,ival;
        double dval;

        ofstream output(xvname.c_str(), ios::out|ios::binary);

        icount=4;
        ival=0;
        output.write((char *)&icount,4);
        output.write((char *)&ival,4);
        output.write((char *)&icount,4);

        icount=3*3*8;
        output.write((char *)&icount,4);
        for(i=0; i<3; i++) {
                latVec[i][0]=info.latConst*info.latVec1[i]*1.8897261;
                output.write((char *)&(latVec[i][0]),8);
                latVec[i][1]=info.latConst*info.latVec2[i]*1.8897261;
                output.write((char *)&(latVec[i][1]),8);
                latVec[i][2]=info.latConst*info.latVec3[i]*1.8897261;
                output.write((char *)&(latVec[i][2]),8);
        }
        output.write((char *)&icount,4);

        output.write((char *)&icount,4);
        for(i=0;i<3;i++){
           for(j=0;j<3;j++){
             dval=0.0;
             output.write((char *)(&dval),8);
           }
        }
        output.write((char *)&icount,4);

        icount=initXV.pos.size()*4;
        output.write((char *)&icount,4);
        for(i=0; i<initXV.pos.size(); i++) {
           ival=info.atomType[i];
           output.write((char *)&ival,4);
        }
        output.write((char *)&icount,4);

        output.write((char *)&icount,4);
        for(i=0; i<initXV.pos.size(); i++) {
           ival=info.atomNum[info.atomType[i]-1];
           output.write((char *)&ival,4);
        }
        output.write((char *)&icount,4);

        icount=initXV.pos.size()*3*8;
        output.write((char *)&icount,4);
        for(i=0; i<initXV.pos.size(); i++) {
           for(j=0;j<3;j++){
             dval=initXV.pos[i].coor[j];
             output.write((char *)&dval,8);
           }
        }
        output.write((char *)&icount,4);

        output.write((char *)&icount,4);
        for(i=0; i<initXV.pos.size(); i++) {
           for(j=0;j<3;j++){
             dval=initXV.vel[i].coor[j];
             output.write((char *)&dval,8);
           }
        }
        output.write((char *)&icount,4);

        output.close();
}
